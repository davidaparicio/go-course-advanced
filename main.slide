Formation Go avancÃ©
01 January 2021

Julien Cretel
jcretel-infosec@protonmail.com
https://jub0bs.com
@jub0bs

* Setup

- Go (>= 1.16)
- Visual Studio Code
- [[https://code.visualstudio.com/docs/languages/go][Go extension for Visual Studio Code]]
- Git

* Overview of the Namecheck project


* Optimize your code for reading



* Use constants provided by packages you import

Critique the following code snippet. What would you improve?

.code src/magicnumbers/magicnumbers.go /^//START/,/^//END/



* Use constants provided by packages you import

Many packages, such as the `http` package, provide useful constants. Use them!

.code src/magicnumbers/nomagicnumbers.go /^//START/,/^//END/

Using constants clarifies your code and reduces the risk for programming errors.

However, don't import packages _just_ for using the constants they export.



* Declare your own clarifying variables and constants

A nameless value is [[https://www.youtube.com/watch?v=5DVV36uqQ4E&t=925s][confusing]]:

  for i := 0; i < 16; i++ {
    go worker(results, job)
  }

Document its meaning through a clarifying identifier:

  const nbWorkers = 16
  for i := 0; i < nbWorkers; i++ {
    go worker(results, job)
  }

Apply the same principle to channel capacities, slice lengths and capacities, etc.

: ignore objections about the value only being used once
: channel capacity often influences correctness and performance of a programme



* Avoid reflect and unsafe

*reflect*

Using the `reflect` package is difficult, leads unreadable code, and often creates performance issues.

*unsafe*

`unsafe` is excluded from the [[https://golang.org/doc/go1compat#expectations][Go 1 compatibility guarantee]]. Importing the `unsafe` package therefore makes your code likely to break with a future release.

Resources:

- [[https://www.youtube.com/watch?v=PAAkCSZUG1c&t=925s][Rob Pike about the `reflect` package]]
- [[https://www.youtube.com/watch?v=ZJFMvWHtSAA][James Bowes - Shattered Mirror: An Introduction to Reflect and Unsafe (dotGo 2019)]].

: if you must use those packages, don't let it leak through your API



* API design


* What is a good API?

A good API

- is easy to use but [[https://www.youtube.com/watch?v=aAb7hSCtvGw&t=6m][hard to misuse]],
- meets its current requirements but is flexible enough to meet anticipated future requirements.

Here are some general principles and specific techniques for designing good APIs in Go.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/friends/stovepipe-hat.svg 200 _



* Encapsulate your types judiciously

Well-encapsulated types are harder to misuse and easier to evolve over time.

For designing a type that provides behaviors and needs to maintain _invariants_, strive for an _opaque_struct_:

- use a struct as the underlying type,
- keep its fields unexported.

If instantiating your type requires some configuration, export _factory_function(s)_ for it.

An example from the `regexp` package:

  type Regexp struct {
      // contains filtered or unexported fields
  }

  func Compile(expr string) (*Regexp, error)

: case first letter of an identifier determines whether exported or not



* Exercise: encapsulate a bidirectional-map type

A bidirectional map, i.e. an associative data structure in which the key-value pairs
form a one-to-one correspondence.

1. Open `go-course-advanced/src/bidirectionalmap` in VS Code.

2. `Bimap` implements a bidirectional map from strings to strings with O(1) access.

3. Review its implementation. What bothers you? How would you improve it?

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 200 _



* Use separate types for data-access objects

Not all types can or should be fully encapsulated. In particular, package such as `encoding/json` require you to export struct fields.

However, you should resist the tendency to design types as mere "property bags".

Don't use the same struct type through all the layers (from presentation through to storage) of your application.

If needed, declare dedicated DTO types for translating your encapsulated types to and from other formats (JSON, XML, etc.).

Reassess those decisions only if you observe performance issues.

: using the same type throughout couples your database schema to the representations
: encapsulation and security issues (mass assignment)
: unlikely to be the bottleneck



* Make the zero value useful

There is no such thing as an uninitialized variable in Go. Every type has a _zero_value_.

For many types, the zero value is readily usable without explicit initialization:
you can simply declare a variable of that type and you safely call its methods.

Some examples and counterexamples from the core library:

  // types whose zero value is readily usable
  bytes.Buffer
  sync.WaitGroup
  sync.Mutex
  http.Client

  // type whose zero value is NOT readily usable
  regexp.Regexp

Try to [[https://www.youtube.com/watch?v=PAAkCSZUG1c&t=6m25s][design your types so that the zero value be readily usable]].



* Why make the zero value useful?

*Convenience*

The zero-value-is-useful property is [[https://golang.org/doc/effective_go#allocation_new][transitive]]: if all the fields of a struct type have a useful zero value, then so does that struct type!

  type SyncedBuffer struct {
      lock    sync.Mutex
      buffer  bytes.Buffer
  }

The need for factory functions is reduced, which leads to a smaller API.

*Correctness*

If you export a type, clients can instantiate the type in its zero value. Therefore,
making the zero value well-behaved renders the type harder to misuse.

: transitive because a struct's zero value has all the fields zeroed
: no way in Go to export a type but prevent people from creating the zero value of that type.
: However, making the zero value useful isn't always possible, esp. for types whose instantiation require some configuration.



* How to make the zero value useful

Approaches to making a type's zero value useful vary.

Sometimes, you can simply modify the type's structure.

In most cases, you need to lazily initializing fields within methods on that type.



* Exercise: make Bimap's zero value useful

1. Re-open `go-course-advanced/src/bidirectionalmap` in VS Code.

2. Is `Bimap`'s zero value usable?

3. If not, make it usable and get rid of factory function `New`.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 200 _



* What if making the zero value useful isn't possible?

For some types, instantiation requires additional information that only clients can provide. Making their zero value useful isn't possible.

When the zero value of your type isn't usable, document it!

Instruct your clients to instatiate the type via a factory function.



* Design secure-by-default enums

The zero values of enum types should be secure / low-privilege.

Don't do this:

  type UserType int
  const (
    Admin UserType = iota
    Employee
    Collaborator
    Anonymous
  )

Do this instead:

  type UserType int
  const (
    Anonymous UserType = iota
    Collaborator
    Employee
    Admin
  )

: User with UserType field would otherwise automatically be an admin!



* Avoid unkeyed literals

Unkeyed struct literals are

- less expressive,
- more error-prone.

Avoid unkeyed literal, especially for types whose declaration is outside your control:

  type Location struct {
    Lat  float64
    Long float64
  }

  strasbourg := Location{48.5734, 7.7521}       // unkeyed literal (avoid!)
  paris := Location{Lat: 48.8566, Long: 2.3522} // keyed literal

: In struct literals, you can either specify all the...
: why error prone: easier to swap the fields,
: won't be affected by reordering of the fields in the type declaration



* Trick for disallowing unkeyed struct literals

Adding an unexported field of type `struct{}` prevents clients of your package
from using unkeyed literals of your type:

.play -edit src/unkeyed/main.go /^//START/,/^//END/



* Avoid global state

Maintaining state at the package level is a [[https://twitter.com/peterbourgon/status/1133492111012184064][recipe for disaster]].

Values of struct types can be stateful; packages shouldn't.

Stay away from `init` functions unless you have to use them.

Don't enumate the _registration_pattern_ (as implemented by the `database/sql` package).



* Dependency injection

Of course, you shouldn't hardcode dependencies,  since it

- creates too much coupling,
- hinders testability.

Instead, simply provide dependencies through interface-type fields on your struct types. If no appropriate interface type is available, define your own!

See how the `namecheck` project uses this approach to inject a HTTP client.

No need for dependency-injection frameworks in Go! Interfaces are enough!

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/fairy-tale/king.svg 200 _




* Documentation and testing



* Document your packages

Go takes a lightweight but powerful approach to documentation: the documentation of a package is simply written as comments in the package's source file(s).

Document your packages and everything it exports. [[https://blog.golang.org/godoc][Follow the conventions]].

You can also write executable examples, which become part of your package's documentation and test suite.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/fairy-tale/witch-learning.svg 200 _

: package's doc: doc.go
: each documentation comment is a complete sentence starting with the name of the element it describes.
: documenting a package doesn't require a lot of effort



* Exercise: document the twitter package

1. Open `go-course-advanced/src/namecheck` in VS Code.

2. Describe the `twitter` package in a `twitter/doc.go` file.

3. Document each of the identifiers exported by `twitter`.

4. Write an example test for the `IsValid` method in `twitter/example_test.go`.

5. Generate the documentation [[https://pkg.go.dev/golang.org/x/tools/cmd/godoc][using `godoc`]].

6. Browse the generated doc and execute the example test in your browser.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 200 _



* Table-driven subtests

If multiple test functions unduly duplicate the testing logic for different test cases,
you can gather those test cases under a single test function and run them as _subtests_:

  func TestIsValid(t *testing.T) {
    cases := []struct{
      label string
      username string
      want bool
    }{
      {label: "too long", username: "obviously_longer_than_15_chars"},
      {label: "too short", username: "foo"},
    }
    for _, c := range cases {
      f := func(t *testing.T) {
        var tw twitter.Twitter
        got := tw.IsValid(c.username)
        if got != c.want {
          t.Errorf("twitter.IsValid(%s): got %t; want %t", c.username, got, c.want)
        }
      }
      t.Run(c.label, f)
    }
  }



* Exercise: switch to table-driven subtests for twitter's IsValid method

1. Open `go-course-advanced/src/namecheck` in VS Code.

2. Coalesce the multiple test functions for `IsValid` into a single test function that uses table-driven subtests.

3. Run those tests.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 200 _



* Test doubles: single-method-interface adapter

To stub or fake a single-method interface like the following,

  type Client interface {
    Do(req *http.Request) (*http.Response, error)
  }

define a function type that implements the interface:

  type clientFunc func(*http.Request) (*http.Response, error)

  func (f clientFunc) Do(req *http.Request) (*http.Response, error) {
    return f(req)
  }

And define factory functions for that type:

  func ClientWithError(err error) Client { /* ... */ }
  func ClientWithStatusCode(sc int) Client { /* ... */ }



* Exercise: write unit tests for IsAvailable

1. Open `go-course-advanced/src/namecheck` in VS Code.

2. Inspect the `stub` package.

3. Write a few table-driven subtests for `twitter`'s IsAvailable method.

4. Run those tests.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 200 _



* Test doubles: generalization to multiple-method interfaces

This pattern can be generalized to multiple-method interfaces by using, instead of a function type, a struct type with function-typed fields:

  type Client interface {
    Do(*http.Request) (*http.Response, error)
    Get(string) (*http.Response, error)
  }

  type stubClient struct {
    do func(*http.Request) (*http.Response, error)
    get func(string) (*http.Response, error)
  }

See [[https://www.youtube.com/watch?v=yeetIgNeIkc][Mat Ryer - Idiomatic Go Tricks (Golang UK 2016)]] (esp. at [[https://www.youtube.com/watch?v=yeetIgNeIkc&t=8m20s][8'20'']] and [[https://www.youtube.com/watch?v=yeetIgNeIkc&t=16m40s][16'40'']])



* Advanced error handling


* Bad error-handling practices

- ignoring errors indiscriminately
- handling (e.g. logging) then returning an error
- simply concatenating error messages
- parsing error messages to access contextual information programmatically
- calling `os.Exit` or `log.Fatal` deep within your program
- panicking willy-nilly
- [[https://play.golang.org/p/WmGrIUbUdmb][recovering from panics]] indiscriminately

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/science/gas-mask.svg 200 _

: source of bugs, mention errcheck
: e.g. if you log an error, don't bubble it up
: concat (advocated in gopl): forces your clients to parse your error messages.
: os.Exit doesn't honor deferred calls
: panicking willy-nilly: errors are values
: recover: you cannot be sure whether the programme is in a valid state



* Report errors appropriate to the level of abstraction

Don't systematically bubble up low-level errors to the caller:

  if err != nil {
    return err
  }

Instead, return a higher-level error that "wraps" the lower-level one.

The easy way is to use the `%w` format directive:

  if err != nil {
      return fmt.Errorf("failure to check username availability: %w", err)
  }

To provide more information, declare your own type that satisfies `error` and `wrapper`:

  type error interface {
    Error() string
  }
  type wrapper interface {
    Unwrap() error
  }

: since Go 1.13
: if we simply bubble up the low-lever error, we lose the context in which this error occurred



* Exercise: define a high-level error for IsAvailable

1. Open `go-course-advanced/src/namecheck` in VS Code.

2. Export a struct type from `namecheck` that represents a failure to check the availability of a username.

3. Make it satisfy the `error` interface.

4. Make it satisfy the `wrapper` interface.

5. Rather than bubbling up the low-level error produces by the `http` package in the `IsAvailable` function, return a pointer to a value of your custom error type.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 200 _



* Inspecting error values: comparison with sentinel errors

Don't stop at `err`!=`nil`. [[https://www.youtube.com/watch?v=PAAkCSZUG1c&t=17m27s][Don't just check errors; handle them gracefully]].

You can compare an error to a specific sentinel error value:

  if err != io.EOF {
    // handle error
  }

Since [[https://blog.golang.org/go1.13-errors][Go 1.13]], you can ask wether the error chain contains the error value of interest:

  if errors.Is(err, io.EOF) {
    // handle error
  }

If you're only interested in the next value up the error chain, do this:

  type wrapper interface { Unwrap() error }
  if err, ok := err.(wrapper); ok { // err has a cause
    // call err.Unwrap to access the error that caused err
  }



* Exercise: inspect the cause of an error

1. Open `go-course-advanced/src/namecheck` in VS Code.

2. In `cmd/cli/main.go`, access the cause of the error returned by `IsAvailable` and print it.

3. To trigger an artificial error, scramble the host in the implementation of `GitHub`'s `IsAvailable` method.

4. Compile and run the program.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 200 _



* Inspecting error values: asserting on behavior

A type assertion can tell you whether an error satisfies a more specific interface:

  type temporary interface {
    Temporary() bool
  }
  if errTemp, ok := err.(temporary); ok {
    // call errTemp.Temporary
    // if it returns true, perhaps retry the operation that failed
  }

Since Go 1.13, you can check whether the error chain contains a value of that interface:

  type temporary interface {
    Temporary() bool
  }
  var errTemp temporary
  if errors.As(err, &errTemp) {
    // call errTemp.Temporary
    // if it returns true, perhaps retry the operation that failed
  }



* Organizing packages



* Use internal packages

An internal package is any package whose path contains a segment named "internal".

It can only be imported by the parent and sibling packages. For example, a package `foo/bar/internal/baz` can only be imported by package `foo/bar` and its subpackages.


Internal packages are [[https://dave.cheney.net/2019/10/06/use-internal-packages-to-reduce-your-public-api-surface][a great language mechanics for restricting the surface area of your project's API]]. They tend to be underused. Use them liberally!

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/fairy-tale/knight.svg 200 _

: great for preventing clients from depending directly on implementation details.
: example: net/http/internal



* Exercise: put common implementation details in an internal package

1. Open `go-course-advanced/src/namecheck` in VS Code.

2. Identify duplication between the `twitter` and `github` package.

3. Create a `namecheck/internal` package.

4. Move the code shared by packages `twitter` and `github` in that internal package.

5. Try importing `namecheck/internal` in `cmd/cli/main.go` and running `go`build`.

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 200 _



* Reminder: no dependency cycles allowed

For example, package `foo` cannot import package `bar` if `bar` itself imports `foo`.

.image img/dependency_cycle.svg 150 _

Imports form a _directed_acyclic_graph_, like the graph of commits in a Git repository.

This design decision by the Go team is a key enabler of fast compilation.

.image https://miro.medium.com/max/4800/1*-bo7H329eM0O1eL_ASBVOA.jpeg 200 _

: any cycle issues in your projects?



* Avoiding dependency cycles

A rule of thumb is that a superpackage doesn't depend on any of its subpackages.

For example, here is a partial view of the `encoding` package and its subpackages:

.image img/dep_arrows_dont_point_down.svg _ 1000

More general stuff at the top; more specific stuff in subpackages.



* Flat is better

To a deep and narrow package hierarchy, prefer a shallow and possibly wide one:

.image img/pkg_shallow_and_wide.svg 400 _



* Structuring your project

If you don't know where to start, adopt a flat structure: everything in a single package.

As structure emerges, create packages organized by context rather than by function.

The structure of your project should tell a story. Avoid MVC layouts!

Resources:

- [[https://medium.com/@benbjohnson/standard-package-layout-7cdbc8391fc1][Ben Jonhson - Standard Package Layout]]
- [[https://www.youtube.com/watch?v=oL6JBUk6tj0][Kat Zien - How Do You Structure Your Go Apps (GopherCon 2018)]]
- [[https://rakyll.org/style-packages/][Jaana B. Dogan - Style guideline for Go packages]]

.image https://www.pngkit.com/png/full/412-4127445_gopher-working-hard-to-move-packages-boxes-golang.png 150 _

: context (twitter, github) ; responsibility (storage)



* Domain-driven design in Go

_Domain-driven_design_(DDD)_is_the_concept_that_the_structure_and_language_of_software_code_should_match_the_business_domain._ ([[https://en.wikipedia.org/wiki/Domain-driven_design][Wikipedia]])

- In a Go monolith, structure your packages around your [[https://martinfowler.com/bliki/BoundedContext.html][_bounded_contexts_]].

- Implicit satisfation makes Go interfaces perfect for [[https://en.wikipedia.org/wiki/Hexagonal_architecture_(software)][_ports_and_adapters_]]!

- Declare named types that reflect your context's [[https://martinfowler.com/bliki/UbiquitousLanguage.html][_ubiquitous_language_]].

- Well-encapsulated types with a useful zero value make for great _domain_objects_.

- Use value (not pointer) method receivers for [[https://martinfowler.com/bliki/ValueObject.html][_value_objects_]].

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/fairy-tale/sage.svg 200 _

: [[https://www.youtube.com/watch?v=B-reKkB8L5Q][Some people]] have even implemented [[https://www.youtube.com/watch?v=JHGkaShoyNs][event-sourced systems]] in Go!
: discuss



* Generics


* What are generics?

Generics, also known as "type parameters", allow [[https://en.wikipedia.org/wiki/Parametric_polymorphism][_parametric_polymorphism_]].

Respondents to the annual Go survey have been [[https://blog.golang.org/survey2020-results][clamoring for them]] for years.

A [[https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md][language proposal]] has been accepted, and generics are finally coming to Go
(most likely [[https://www.youtube.com/watch?v=BNHwHLNLjLs&t=29m][by the end of 2021]]), without breaking compatibility with Go 1.0!

You can experiment with Go generics in a [[https://go2goplay.golang.org/][special Playground]].

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/party/birthday.svg 200 _

: familiar with generics?



* Why generics matter

The advent of generics is promising:

- more flexible and reusable functions and [[https://jub0bs.com/posts/2020-07-21-go-bimap][data structures]]
- more efficient code at run time (at the cost of longer compilation)
- more type safety (fewer use cases for the empty interface)
- fewer reasons to resort to code generation

See [[https://blog.golang.org/why-generics][_Why_Generics?_]] on the golang blog (the syntax is outdated, though).

Some people worry that generics are going to compromise Go's agenda of simplicity.
Time will tell...

: e.g. generic function for reversing a slice
: What do you think?
: see use cases in your code? do you use go generate?



* Exercise: make a binary-tree type generic

1. Open [[https://go2goplay.golang.org/p/ogVJA0hyXpm][https://go2goplay.golang.org/p/ogVJA0hyXpm]].

2. The `Tree` type represents a binary tree. Study its implementation.

3. Modify the code to make `Tree` and its methods generic. Any issues?

.image https://raw.githubusercontent.com/egonelbre/gophers/master/vector/superhero/gotham.svg 200 _

: solution: https://go2goplay.golang.org/p/Pq3wA9WjdgO



* Context


* Goroutines die hard

You can start goroutines very easily: all it takes is the `go` keyword.

However, if you're careless, the goroutines you spawn may never terminate.

.play -edit src/uncancellable/main.go /^//START/,/^//END/

: everyone ok with go keyword and wait groups?



* The golden rule

Before spawning a new goroutine, you must understand exactly under what conditions it will terminate.

If you're careless and spawn goroutines willy-nilly, you expose yourself to correctness and performance bugs (_goroutine_leaks_).

.image https://www.globalnerdy.com/wp-content/uploads/2017/08/gopher-this-is-fine.jpg 300 _



* Context is for cancellation

The `context` package provides a `Context` type.

  type Context interface {
    Deadline() (deadline time.Time, ok bool)
    Done() <-chan struct{}
    Err() error
    Value(key interface{}) interface{}
  }

Its primary purpose is to *broadcast*a*cancellation*signal* to child goroutines.
The cancellation signal may be sent explicitly or time-based.

We'll talk about `Context`'s secondary (more controversial) purpose later.



* Detecting context cancellation via the Err method

.play -edit src/cancellableerr/main.go /^//START/,/^//END/



* Detecting context cancellation via the Done method

This is more idiomatic than using the `Err` method, though:

.play -edit src/cancellablechan/main.go /^//START/,/^//END/
